### 1：支叶主程序 自带 Y语言 函数接口

##### 1.1：创建线程

| 接口 | createth | 从系统中分配一定的CPU与内存资源独立执行一段Y语言代码 |
| ---- | -------- | ---------------------------------------------------- |
| 入参 | Ycode    | Y语言执行代码块，用{}扩起来                          |
| 返回 | fd       | 成功返回 线程句柄，失败返回 false                    |

```c
fd createth(Ycode) // fh=createth({ while(1) {out11;sleep(1000);}})
```



##### 1.2：结束线程

| 接口 | killth | 通过句柄参数找到对应的线程，并结束它（注：killth 可能存在资源不释放的问题，最好是Ycode执行过程自己结束） |
| ---- | ------ | ------------------------------------------------------------ |
| 入参 | fd     | createth 返回的句柄                                          |
| 返回 | bool   | 成功返回 true，失败返回 false                                |

```c
bool killth(fd) // fh=createth({...}); ...... killth(fh)
```



##### 1.3：创建定时器

| 接口 | starttimer         | 创建一个定时任务，指定时间运行Y语言代码段                    |
| ---- | ------------------ | ------------------------------------------------------------ |
| 入参 | Ycode              | Y语言执行代码块，用{}扩起来                                  |
| 入参 | starttimeS         | 起动时间(单位秒)，支持浮点(如0.2为200ms)                     |
| 入参 | IntervaltimeS/null | 间隔时间(单位秒)，支持浮点(如0.01为10ms);当只执行一次时，这个参数省略 |
| 返回 | fd                 | 成功返回 定时器句柄，失败返回 false                          |

```c
fd starttimer(Ycode,starttimeS,IntervaltimeS/null) 
// ft=starttimer({out(11)},5);	// 5秒后执行{out(11)}，代码段的执行结果是窗口打印出11。
// a=1; ft=starttimer({out(a);a++;},2,0.5);	// 2秒后执行{out(a);a++;},之后每间隔0.5S再执行一次，代码段的执行结果是在窗口上打印a的值，再将a自加1。
```



##### 1.4：停止定时器

| 接口 | stoptimer | 通过句柄参数找到对应的定时器，并停止它 |
| ---- | --------- | -------------------------------------- |
| 入参 | fd        | starttimer返回的句柄                   |
| 返回 | bool      | 成功返回 true，失败返回 false          |

```c
bool stoptimer(fd) // ft=starttimer({...}，...); ...... stoptimer(ft)
```

